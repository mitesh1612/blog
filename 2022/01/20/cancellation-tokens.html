<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>A Deep Dive into C#‚Äôs CancellationToken | Mitesh Shah‚Äôs Blog</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="A Deep Dive into C#‚Äôs CancellationToken" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An introduction and deep dive into CancellationToken to achieve cancellation in asynchronous operations, alongwith recommended patterns to use it." />
<meta property="og:description" content="An introduction and deep dive into CancellationToken to achieve cancellation in asynchronous operations, alongwith recommended patterns to use it." />
<link rel="canonical" href="https://mitesh1612.github.io/blog/2022/01/20/cancellation-tokens" />
<meta property="og:url" content="https://mitesh1612.github.io/blog/2022/01/20/cancellation-tokens" />
<meta property="og:site_name" content="Mitesh Shah‚Äôs Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-20T00:00:00-06:00" />
<script type="application/ld+json">
{"url":"https://mitesh1612.github.io/blog/2022/01/20/cancellation-tokens","@type":"BlogPosting","headline":"A Deep Dive into C#‚Äôs CancellationToken","dateModified":"2022-01-20T00:00:00-06:00","datePublished":"2022-01-20T00:00:00-06:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mitesh1612.github.io/blog/2022/01/20/cancellation-tokens"},"description":"An introduction and deep dive into CancellationToken to achieve cancellation in asynchronous operations, alongwith recommended patterns to use it.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://mitesh1612.github.io/blog/feed.xml" title="Mitesh Shah's Blog" /><link rel="shortcut icon" type="image/x-icon" href="/blog/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Mitesh Shah&#39;s Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">About Me</a><a class="page-link" href="/blog/search/">Search</a><a class="page-link" href="/blog/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">A Deep Dive into C#&#39;s CancellationToken</h1><p class="page-description">An introduction and deep dive into CancellationToken to achieve cancellation in asynchronous operations, alongwith recommended patterns to use it.</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-01-20T00:00:00-06:00" itemprop="datePublished">
        Jan 20, 2022
      </time>
       ‚Ä¢ <span class="read-time" title="Estimated read time">
    
    
      14 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/blog/categories/#C#">C#</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#deep-dive">deep-dive</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#asynchronous">asynchronous</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>One of my goals for writing this blog was to store things I learnt for myself and refer to them later (while also sharing it with the world) and today‚Äôs post is something along those lines.</p>

<p>Recently I have started dabbling into asynchronous programming in C# while writing a side project, and I saw a lot of methods using something called <code class="language-plaintext highlighter-rouge">CancellationToken</code> in their signatures. I knew it was related to cancelling an asynchronous operation (name is a dead giveaway, right?), but that was the extent of my knowledge. So I did a deep dive into the topic, and here I present a shorter version of everything I learnt so far.</p>

<p>Do note that this post doesn‚Äôt cover how to do asynchronous programming or the TAP/Task-based Asynchronous Pattern, <a href="https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">here is a great reference from Microsoft docs</a>, if you want a refresher on those topics</p>

<p>Also, eventhough this post is really specific to C#, the design of CancellationToken is pretty interesting and this can be an interesting read for you, eventhough your language of choice isn‚Äôt C#, so do read on. üòä</p>

<h2 id="so-what-is-a-cancellationtoken">So what is a <code class="language-plaintext highlighter-rouge">CancellationToken</code>?</h2>

<p>Obviously, asynchronous code is good for long running operation, and the provided task mechanism is plenty powerful. But sometimes we need to control the execution flow of this tasks. Why? We want observability into our tasks and not let some task hold the CPU and thread pool and hog down precious resources. Sometimes we want to have a difference between a task getting cancelled manually versus cancelling it due to an exception (or timeout?).</p>

<p>Well worry not, .NET provides us with a mechanism for cooperative cancellation of asynchronous operations, based on a lightweight object called <em>cancellation token</em>.</p>

<h3 id="basic-mental-model-for-the-cancellation-tokens">Basic Mental Model for the Cancellation Tokens</h3>

<p>We have an object that creates one or more long running asynchronous operations. This object will pass this token to all of these operations. The individual operations can in turn pass copies of this token to other operations as well. At some later time, the object that created the token can use it to request the operations to stop what they are doing, essentially requesting a cancellation. This request can only be issued by the requesting object, i.e. no individual operation can cancel itself and other operations with that token. Importantly, each listener is responsible for noticing the request and responding to it in an appropriate and timely manner.</p>

<p>I know we already have a lot of text, but hey don‚Äôt worry. Soon I‚Äôll add pictures and code to make it even more clearer, while also diving deep into how to do each of the things specified above.</p>

<h3 id="how-does-net-achieve-this">How does .NET achieve this?</h3>

<p>.NET provides 2 classes, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource?view=net-6.0">CancellationTokenSource</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken?view=net-6.0">CancellationToken</a> to achieve the cancellation mechanism.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">CancellationTokenSource</code></strong> - This is the object responsible for creating a cancellation token and sending a cancellation request to all copies of that token.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">CancellationToken</code></strong> - This is the structure used by listeners to monitor the token‚Äôs current state.</li>
</ul>

<p>There is one more type that is involved, <strong><code class="language-plaintext highlighter-rouge">OperationCancelledException</code></strong>. Listeners of the cancellation token can optionally throw this exception to verify the source of the cancellation and notify others that it has responed to a cancellation request.</p>

<p>The <strong>general pattern</strong> to implement the above stated, cooperative cancellation model is as follows:</p>

<ul>
  <li>Instantiate a <code class="language-plaintext highlighter-rouge">CancellationTokenSource</code> object</li>
  <li>Pass the token returned by the <code class="language-plaintext highlighter-rouge">CancellationTokenSource.Token</code> property to each task or thread that listens for cancellation</li>
  <li>Provide a mechanism for each task or thread to respond to this cancellation</li>
  <li>Call the <code class="language-plaintext highlighter-rouge">CancellationTokenSource.Cancel</code> method to provide a notification for cancellation</li>
</ul>

<p>Well this covers the basics, and you can rightfully jump off to dabble into using it. But if you will, stay to see how to do each of the above steps, especially 3, since there are various ways to do it.</p>

<p>Here is an illustration that I totally stole from Microsoft docs showing the relationship between a token source and all of the copies of its token.</p>

<p><img src="https://docs.microsoft.com/en-us/dotnet/standard/threading/media/vs-cancellationtoken.png" /></p>

<p>The important aspect here is that this model is cooperative, i.e., the cancellation is not forced on the listener. The listener can determine how to gracefully terminate in response to a cancellation request.</p>

<p>Also the source can issue a cancellation request to all copies of the token by using one method call, which makes cancelling a complex task or its sub tasks simple and easy using a single cancellation token.</p>

<p>A listener of the cancellation token can also listen to multiple tokens at once, by joining them into one <em>linked token</em>.</p>

<p>Listeners can implement a variety of mechanisms like polling, callbacks or wait handles to get notified of cancellation, thus giving flexibility.</p>

<p>Now lets see some code to see how we can use Cancellation Tokens.</p>

<h2 id="example-of-using-cancellation-token">Example of using Cancellation Token</h2>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">CancellableMethod</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">tokenSource</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
    <span class="c1">// Queue some long running tasks</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span><span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DoSomeWork</span><span class="p">(</span><span class="n">tokenSource</span><span class="p">.</span><span class="n">Token</span><span class="p">),</span> <span class="n">tokenSource</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// After some delay/when you want manual cancellation</span>
    <span class="n">tokenSource</span><span class="p">.</span><span class="nf">Cancel</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Runs on a different thread</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoSomeWork</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxIterations</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span><span class="n">i</span> <span class="p">&lt;</span> <span class="n">maxIterations</span><span class="p">;++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Do some long running work</span>

        <span class="k">if</span><span class="p">(</span><span class="n">ct</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Task cancelled."</span><span class="p">);</span>
            <span class="n">ct</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
        <span class="p">}</span>

    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here we start cancellable tasks and pass the cancellation token to the delegate that‚Äôs running. Passing to the task here is optional. User delegate notices and responds to the cancellation request. That way the calling thread can not forcibly end the task, just signal that cancellation is requested and the delegate/task can notice the request and respond to it appropriately.</p>

<h2 id="cancellation-token-is-for-operations-not-objects">Cancellation Token is for Operations, not Objects</h2>

<p>Here in this framework, the cancellation is referred for operations, not objects. That way, one cancellation token should refer to a ‚Äúcancellable operation‚Äù. Once the <code class="language-plaintext highlighter-rouge">IsCancellationRequested</code> property in a cancellation token is set to <code class="language-plaintext highlighter-rouge">true</code>, it can‚Äôt be set to <code class="language-plaintext highlighter-rouge">false</code> again and you cant reuse the same cancellation token again after its cancelled.</p>

<h2 id="how-to-listen-and-respond-to-cancellation-requests">How to Listen and Respond to Cancellation Requests</h2>

<p>A cancellable operation or the listener has to determine on how to terminate gracefully and how to respond to a cancellation request. Usually some required cleanup is performed and then the delegate responds immediately.</p>

<p>However, in more complex cases, it might be necessary for the user delegate to notify library code that cancellation has occurred. In such cases, the correct way to terminate the operation is for the delegate to call the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken.throwifcancellationrequested">ThrowIfCancellationRequested</a>, method, which will cause an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.operationcanceledexception">OperationCanceledException</a> to be thrown. Library code can catch this exception on the user delegate thread and examine the exception‚Äôs token to determine whether the exception indicates cooperative cancellation or some other exceptional situation.</p>

<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task">Task</a> class handles the OperationCancelledException in this way. (See the benefit of passing the Cancellation token to the task now?)</p>

<p>Here are a few mechanisms on how the user delegate can monitor the cancellation request</p>

<h3 id="listening-by-polling">Listening by Polling</h3>

<p>For long running operations that are implemented in loops (like in the example above) or recursive methods, listener can listen to the value for a cancellation request by polling the value of <code class="language-plaintext highlighter-rouge">CancellationToken.IsCancellationRequested</code> property. If the value is <code class="language-plaintext highlighter-rouge">true</code>, the method can perform required cleanup and terminate as quickly as possible.</p>

<p>The optimal frequency of polling this property is something that‚Äôs application dependent and is upto the developer to determine the best frequency. Here is a small example for this approach</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">SomeLongRunningOperation</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span><span class="p">(!</span><span class="n">ct</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nf">DoWork</span><span class="p">();</span> <span class="c1">// perform one unit of work</span>
    <span class="p">}</span>

    <span class="c1">// perform cleanup if needed</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is how a lot of <code class="language-plaintext highlighter-rouge">BackgroundServices</code> are implemented.</p>

<p>There is another variant of this, where instead of breaking out of the loop, we can use the <code class="language-plaintext highlighter-rouge">ThrowIfCancellationRequested</code> method to throw an appropriate <code class="language-plaintext highlighter-rouge">OperationCancelledException</code>. Prefer this instead of manually throwing this exception.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">SomeLongRunningOperation</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nf">DoWork</span><span class="p">();</span> <span class="c1">// perform one unit of work</span>
        <span class="n">ct</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span> <span class="c1">// this is extremely fast</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For more details on this approach, refer to <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/how-to-listen-for-cancellation-requests-by-polling">this link</a>.</p>

<h3 id="listening-by-registering-a-callback">Listening by Registering a Callback</h3>

<p>Some operations can become blocked in such a way that they cannot check the value of the cancellation token in a timely manner. For these cases, you can register a callback method that unblocks the method when a cancellation request is received.</p>

<p>The <code class="language-plaintext highlighter-rouge">Register</code> method is used for this purpose. It also returns a <code class="language-plaintext highlighter-rouge">CancellationTokenRegistration</code> type of object, which can also be used to unregister this callback, for whatever reason you might want to.</p>

<p>Lets look at an example of cancelling a web request, using this approach:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">DownloadSomeHugeFile</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">WebClient</span> <span class="n">wc</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WebClient</span><span class="p">();</span>

    <span class="n">ct</span><span class="p">.</span><span class="nf">Register</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">wc</span><span class="p">.</span><span class="nf">CancelAsync</span><span class="p">();</span>
    <span class="p">});</span>
    <span class="c1">// optionally can also store this registration in a variable</span>

    <span class="n">wc</span><span class="p">.</span><span class="nf">DownloadStringAsync</span><span class="p">(</span><span class="s">"https://some-download-path"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now whenever the source requests a cancellation, the registered callback will be called and cancellation occurs. This registration object manages thread synchronization and ensures that the callback will stop executing at a precise point in time.</p>

<p><strong>Note</strong>, The callback method should be fast because it is called synchronously and therefore the call to <code class="language-plaintext highlighter-rouge">Cancel</code> does not return until the callback returns.</p>

<p>For more details, you can refer to <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads#listening-by-registering-a-callback">this link</a>.</p>

<p>There is one more way by using Wait Handles. But I don‚Äôt know about them enough to blog about them. Hence if you are interested in that approach, sorry, but here‚Äôs Microsoft docs <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/how-to-listen-for-cancellation-requests-that-have-wait-handles">reference</a> that might be able to help you.</p>

<h2 id="listening-to-multiple-tokens-simultaneously">Listening to Multiple Tokens Simultaneously</h2>

<p>In some cases, a listener may have to listen to multiple cancellation tokens simultaneously. For example, a cancelable operation may have to monitor an internal cancellation token in addition to a token passed in externally as an argument to a method parameter. To accomplish this, create a linked token source that can join two or more tokens into one token.</p>

<p>Here is a code example:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">void</span> <span class="nf">DoWork</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">internalTokenSource</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
    <span class="n">internalTokenSource</span><span class="p">.</span><span class="nf">CancelAfter</span><span class="p">(</span><span class="m">10000</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">internalToken</span> <span class="p">=</span> <span class="n">internalTokenSource</span><span class="p">.</span><span class="n">Token</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">externalToken</span> <span class="p">=</span> <span class="n">ct</span><span class="p">;</span>
    <span class="k">using</span> <span class="p">(</span><span class="n">CancellationTokenSource</span> <span class="n">linkedCts</span> <span class="p">=</span> <span class="n">CancellationTokenSource</span><span class="p">.</span><span class="nf">CreateLinkedTokenSource</span><span class="p">(</span><span class="n">internalToken</span><span class="p">,</span> <span class="n">externalToken</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="nf">DoWorkInternal</span><span class="p">(</span><span class="n">linkedCts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(</span><span class="n">OperationCancelledException</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">internalToken</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Operation timed out"</span><span class="p">);</span>
            <span class="p">}</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">externalToken</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Cancelling per user request."</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><strong>Note</strong>, When the linked token throws an OperationCanceledException, the token that is passed to the exception is the linked token, not either of the predecessor tokens. To determine which of the tokens was canceled, check the status of the predecessor tokens directly.</p>

<p>For more details on this approach, use <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/how-to-listen-for-multiple-cancellation-requests">this reference</a>.</p>

<p>Well, that was a lot of details on Cancellation Tokens, but I feel inspired today. So I think of extending this post by adding some recommended patterns as well.</p>

<h2 id="recommended-patterns-for-cancellation-tokens">Recommended Patterns for Cancellation Tokens</h2>

<p>I wish I knew a lot about cancellation tokens to recommend some patterns of my own. But until then, I am sharing the patterns refererred to <a href="https://devblogs.microsoft.com/premier-developer/recommended-patterns-for-cancellationtoken/">in this excellent blog</a>. It‚Äôs a wonderful article giving some great guidelines on how to design and work around cancellation tokens.</p>

<p>Using cancellation tokens is a great pattern, but supporting these require some extra responsibility.</p>

<h3 id="1-know-when-youve-passed-the-point-of-no-cancellation">1. Know when you‚Äôve passed the point of no cancellation</h3>

<p><strong>Don‚Äôt</strong> cancel if you‚Äôve already incurred side-effects that your method isn‚Äôt prepared to revert on the way out that would leave you in an inconsistent state. So if you‚Äôve done some work, and have a lot more to do, and the token is cancelled, you must only cancel when and if you can do so leaving objects in a valid state. This may mean that you have to finish the large amount of work, or undo all your previous work (i.e. revert the side-effects), or find a convenient place that you can stop halfway through but in a valid condition, before then throwing OperationCanceledException. In other words, the caller must be able to recover to a known consistent state after cancelling your work, or realize that cancellation was not responded to and that the caller then must decide whether to accept the work, or revert its successful completion on its own.</p>

<h3 id="2-propagate-your-cancellationtoken">2. Propagate your CancellationToken</h3>

<p>Propagate your CancellationToken to all the methods you call that accept one, except after the ‚Äúpoint of no cancellation‚Äù referred to in the previous point. In fact if your method mostly orchestrates calls to other methods that themselves take CancellationTokens, you may find that you don‚Äôt personally have to call CancellationToken.ThrowIfCancellationRequested() at all, since the async methods you‚Äôre calling will generally do it for you.</p>

<h3 id="3-dont-throw-operationcancelledexception-after-youve-completed-the-work">3. Don‚Äôt throw OperationCancelledException after you‚Äôve completed the work</h3>

<p>Don‚Äôt throw OperationCanceledException after you‚Äôve completed the work, just because the token was signaled. Return a successful result and let the caller decide what to do next. The caller can‚Äôt assume you‚Äôre cancellable at a given point anyway so they have to be prepared for a successful result even upon cancellation.</p>

<h3 id="4-input-validation">4. Input Validation</h3>

<p>Input Validation can certainly go ahead of cancellation checks (since that helps highlight bugs in the calling code).</p>

<h3 id="5-consider-not-checking-the-token-at-all">5. Consider not checking the token at all</h3>

<p>Consider not checking the token at all if your work is very quick, or you propagate it to the methods you call. That said, calling CancellationToken.ThrowIfCancellationRequested() is pretty lightweight so don‚Äôt think too hard about this one unless you see it on perf traces.</p>

<h3 id="optional-parameters-for-cancellation-tokens">Optional Parameters for cancellation tokens</h3>

<p>If you want to accept CancellationToken but want to make it optional, you can do so with syntax such as this:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">Task</span> <span class="nf">SomethingExpensiveAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">cancellationToken</span> <span class="p">=</span> <span class="k">default</span><span class="p">(</span><span class="n">CancellationToken</span><span class="p">))</span>
<span class="p">{</span>
  <span class="c1">// don't worry about NullReferenceException if the</span>
  <span class="c1">// caller omitted the argument because it's a struct.</span>
  <span class="n">cancellationToken</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It‚Äôs a good idea to only make your CancellationToken parameters optional in your public API (if you have one) and leave them as required parameters everywhere else. This really helps to ensure that you intentionally propagate your CancellationTokens through all the methods you call (#2 above). But of course remember to switch to passing CancellationToken.None once you pass the point of no cancellation.</p>

<p>It‚Äôs also a good API pattern to keep your CancellationToken as the last parameter your method accepts. This fits nicely with optional parameters anyway since they have to show up after any required parameters.</p>

<h3 id="how-to-handle-cancellation-exceptions">How to handle cancellation exceptions</h3>

<p>If you‚Äôve experienced cancellation before, you‚Äôve probably noticed a couple of types of these exceptions: <code class="language-plaintext highlighter-rouge">TaskCanceledException</code> and <code class="language-plaintext highlighter-rouge">OperationCanceledException</code>. TaskCanceledException derives from OperationCanceledException. That means when writing your catch blocks that deal with the fallout of a canceled operation, you should catch OperationCanceledException. If you catch TaskCanceledException you may let certain cancellation occurrences slip through your catch blocks (and possibly crash your app).</p>

<p>If your cancelable method is in between other cancelable operations, you may need to perform clean up when canceled. When doing so, you can use the catch block, but be sure to rethrow properly:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="n">Task</span> <span class="nf">SendResultAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">try</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="n">httpClient</span><span class="p">.</span><span class="nf">SendAsync</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">cancellationToken</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span> <span class="n">ex</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// perform your cleanup</span>
    <span class="n">form</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>

    <span class="c1">// rethrow exception so caller knows you've canceled.</span>
    <span class="c1">// DON'T "throw ex;" because that stomps on</span>
    <span class="c1">// the Exception.StackTrace property.</span>
    <span class="k">throw</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="in-conclusion">In conclusion</h2>

<p>This post became inceremoniously too long, but it stands as a great reference on how CancellationTokens work, how to listen to them and what design considerations should be done while using it. Let me know in the comments if you liked this deep dive or felt it was too long and textual. Also do sound off if you want me to do deep dives on other topics as well.</p>

<p>If you liked what you read, you can try reading some other posts on my blog as well, and you can also connect with me on my socials. Until next time. üòä</p>

  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="mitesh1612/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/blog/2022/01/20/cancellation-tokens" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Mitesh Shah&#39;s Developer Blog, made using Fastpages</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/mitesh1612" target="_blank" title="mitesh1612"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/mitesh_1612" target="_blank" title="mitesh_1612"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
